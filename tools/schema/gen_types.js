var _ = require("lodash");
var fs = require("fs");
var xml2js = require("xml2js");

var settings = require("./settings");

var types_xml = `${settings.schema_dir}/Opc.Ua.Types.bsd.xml`;

var rs_out = fs.createWriteStream(`${settings.rs_dir}/types/generated/types.rs`);

/// This code parses the OPC UA Binary types definitions and creates a generated types.rs file
/// Fields are converted to snake case as they are written. Code for serializing the struct is also generated

/// Any handwritten types are stripped from the output

var ignored_types =
  [
    "Variant"
  ];
/*
write_to_rs(rs_out,
`// This file was autogenerated from Opc.Ua.Types.bsd.xml

use types::*;
use super::types::*;

`);

*/


var parser = new xml2js.Parser();
fs.readFile(types_xml, function(err, data) {
  parser.parseString(data, function (err, result) {
    var structured_types = result["opc:TypeDictionary"]["opc:StructuredType"];
    _.each(structured_types, function (structured_type) {

      var name = structured_type["$"]["Name"];

      // TODO if name in ignored_types, do nothing

      var base_type = structured_type["$"]["BaseType"];
      var doc =

      console.log(`pub struct ${name} {`);

      _.each(structured_type["opc:Field"], function(field) {
        // Convert field name to snake case
        var field_name = _.snakeCase(field["$"]["Name"]);

        // Strip namespace off the type
        var type = field["$"]["TypeName"].split(":")[1];

        // Replace String with UAString
        if (type === "String") {
          type = "UAString";
        }

        console.log(`    pub ${field_name}: ${type},`);
      })

      console.log(`};`);
    });
  });
});

