var _ = require("lodash");
var fs = require("fs");
var xml2js = require("xml2js");

var settings = require("./settings");

const MAX_NODES_PER_FILE = 100;

var trace = false;

// THIS file will generate the address space

var node_set =
    [
        {
            name: "Opc.Ua.NodeSet2.Part3.xml", module: "nodeset_3"
        },
        {
            name: "Opc.Ua.NodeSet2.Part4.xml", module: "nodeset_4"
        },
        {
            name: "Opc.Ua.NodeSet2.Part5.xml", module: "nodeset_5"
        },
        {
            name: "Opc.Ua.NodeSet2.Part8.xml", module: "nodeset_8"
        },
        {
            name: "Opc.Ua.NodeSet2.Part9.xml", module: "nodeset_9"
        },
        {
            name: "Opc.Ua.NodeSet2.Part10.xml", module: "nodeset_10"
        },
        {
            name: "Opc.Ua.NodeSet2.Part11.xml", module: "nodeset_11"
        },
        {
            name: "Opc.Ua.NodeSet2.Part12.xml", module: "nodeset_12"
        },
        {
            name: "Opc.Ua.NodeSet2.Part13.xml", module: "nodeset_13"
        },
        {
            name: "Opc.Ua.NodeSet2.Part14.xml", module: "nodeset_14"
        },
        {
            name: "Opc.Ua.NodeSet2.Part999.xml", module: "nodeset_999"
        }
    ];

///////////////////////////////////////////////////////////////////////////////
// Parse all XML inputs into data and place it on the node sets above

let parser = new xml2js.Parser();

let modules = [];
_.each(node_set, function (ns) {
    let data = fs.readFileSync(`${settings.schema_dir}/${ns.name}`);
    parser.parseString(data, function (err, result) {
        ns.data = result;
        console.log(`Generating code for module ${ns.module}`);
        let node_set_modules = generate_node_set(ns);
        modules.push(...node_set_modules)
    });
});
console.log(`modules = ${modules}`)

///////////////////////////////////////////////////////////////////////////////
// Create the mod.rs

let mod_contents = `// This file was autogenerated by tools/schema/gen_address_space.js
// DO NOT EDIT THIS FILE

use crate::address_space::types::AddressSpace;

`;

// use each part
_.each(modules, function (module) {
    mod_contents += `mod ${module};\n`
});
mod_contents += `\n`;

// in a populate_address_space method
mod_contents += `/// Populates the address space with all defined node sets
pub fn populate_address_space(address_space: &mut AddressSpace) {\n`;

_.each(modules, function (module) {
    mod_contents += `    ${module}::populate_address_space(address_space);\n`
});

mod_contents += `}\n`;

settings.write_to_file(`${settings.rs_address_space_dir}/mod.rs`, mod_contents);


///////////////////////////////////////////////////////////////////////////////
// All files to be created under server/src/address_space/generated/
function generate_node_set(ns) {
    // Gather up all the nodes in the nodeset
    let nodeset = ns.data["UANodeSet"];

    var nodes = [];
    if (_.has(nodeset, "UAObject")) {
        _.each(nodeset["UAObject"], function (node) {
            nodes.push(["Object", node]);
        });
    }
    if (_.has(nodeset, "UAObjectType")) {
        _.each(nodeset["UAObjectType"], function (node) {
            nodes.push(["ObjectType", node]);
        });
    }
    if (_.has(nodeset, "UADataType")) {
        _.each(nodeset["UADataType"], function (node) {
            nodes.push(["DataType", node]);
        });
    }
    if (_.has(nodeset, "UAReferenceType")) {
        _.each(nodeset["UAReferenceType"], function (node) {
            nodes.push(["ReferenceType", node]);
        });
    }
    if (_.has(nodeset, "UAVariable")) {
        _.each(nodeset["UAVariable"], function (node) {
            nodes.push(["Variable", node]);
        });
    }
    if (_.has(nodeset, "UAVariableType")) {
        _.each(nodeset["UAVariableType"], function (node) {
            nodes.push(["VariableType", node]);
        });
    }
    if (_.has(nodeset, "UAMethod")) {
        _.each(nodeset["UAMethod"], function (node) {
            nodes.push(["Method", node]);
        });
    }

    // Generate source files for the nodeset, ensuring no more than MAX_NODES_PER_FILE
    let modules = [];
    if (nodes.length <= MAX_NODES_PER_FILE) {
        modules.push(generate_node_set_files(ns.name, ns.module, 0, nodes));
    } else {
        let part_nr = 1;
        let node_start = 0;
        while (node_start < nodes.length) {
            let node_slice = nodes.slice(node_start, node_start + MAX_NODES_PER_FILE);
            modules.push(generate_node_set_files(ns.name, ns.module, part_nr++, node_slice));
            node_start += MAX_NODES_PER_FILE;
        }
    }
    return modules;
}

function generate_node_set_files(xml_name, rs_name, part_nr, nodes) {
    let module_name = part_nr > 0 ? `${rs_name}_${part_nr}` : `${rs_name}`
    let file_name = `${module_name}.rs`;

    // Process all the nodes
    let contents = `// This file was autogenerated from ${xml_name} by tools/schema/gen_address_space.js
// DO NOT EDIT THIS FILE

#[allow(unused_imports)]
use std::str::FromStr;

#[allow(unused_imports)]
use opcua_types::{
    node_id::NodeId,
    data_value::DataValue,
    variant::Variant, 
    extension_object::ExtensionObject, 
    string::UAString,
    basic_types::LocalizedText,
    service_types::{
        Argument
    },
    node_ids::*
};
#[allow(unused_imports)]
use crate::address_space::types::*;

`;

    let fn_names = [];
    let idx = 1;
    _.each(nodes, function (tuple) {
        let node_type = tuple[0];
        let node = tuple[1];
        let fn_name = insert_node_fn_name(idx++, node_type);
        fn_names.push(fn_name);
    });

    contents += "#[allow(unused_variables)]\n";
    contents += `pub fn populate_address_space(address_space: &mut AddressSpace) {\n`;
    if (trace) {
        contents += `    trace!("Populating address space with node set ${ns.name}");\n`
    }
    _.each(fn_names, function (fn_name) {
        contents += `    ${fn_name}(address_space);\n`;
    });
    contents += `}\n\n`;

    idx = 0;
    _.each(nodes, function (tuple) {
        let node_type = tuple[0];
        let node = tuple[1];
        contents += insert_node(fn_names[idx++], node_type, node);
    });

    settings.write_to_file(`${settings.rs_address_space_dir}/${file_name}`, contents);
    return module_name;
}

function insert_node_fn_name(idx, node_type) {
    return `add_${node_type.toLowerCase()}_${idx}`;
}

function node_id_ctor(snippet) {
    // This turns a snippet like "i=2015" into a node id
    return `NodeId::new(0, ${snippet.substr(2)})`;
}

function insert_node(fn_name, node_type, node) {
    let contents = `fn ${fn_name}(address_space: &mut AddressSpace) {\n`;
    let indent = "    ";

    contents += `${indent}// ${node_type}\n`;

    let node_ctor = "";

    // Process values
    if (node_type === "Object") {
        node_ctor = "Object::new(&node_id, browse_name, display_name, description)";
    } else if (node_type === "ObjectType") {
        let is_abstract = _.has(node["$"], "IsAbstract") && node["$"]["IsAbstract"] === "true";
        node_ctor = `ObjectType::new(&node_id, browse_name, display_name, description, ${is_abstract})`;
    } else if (node_type === "DataType") {
        let is_abstract = _.has(node["$"], "IsAbstract") && node["$"]["IsAbstract"] === "true";
        node_ctor = `DataType::new(&node_id, browse_name, display_name, description, ${is_abstract})`;
    } else if (node_type === "ReferenceType") {
        let is_abstract = _.has(node["$"], "IsAbstract") && node["$"]["IsAbstract"] === "true";
        let inverse_name = _.has(node, "InverseName") ? `Some(LocalizedText::new("", "${node["InverseName"][0]}"))` : "None";
        let symmetric = _.has(node["$"], "Symmetric") && node["$"]["Symmetric"] === "true";
        node_ctor = `ReferenceType::new(&node_id, browse_name, display_name, description, ${inverse_name}, ${symmetric}, ${is_abstract})`
    } else if (node_type === "Variable") {
        let data_type = "DataTypeId::Boolean";
        if (_.has(node["$"], "DataType")) {
            data_type = node["$"]["DataType"];
            if (data_type.startsWith("i=")) {
                data_type = `DataTypeId::from_u32(${data_type.substr(2)}u32).unwrap()`;
            } else {
                data_type = `DataTypeId::${data_type}`;
            }
        } else {
            console.log("UAVariable has no data type???");
        }
        let data_value_is_set = false;
        if (_.has(node, "Value")) {
            let value = node["Value"][0];
            if (_.has(value, "ListOfLocalizedText")) {
                // TODO process ListOfLocalizedText
            }

            if (_.has(value, "ListOfExtensionObject")) {

                // Process ListOfExtensionObject looking for Argument types
                let list = value["ListOfExtensionObject"][0];

                let var_arguments = [];
                _.each(list["ExtensionObject"], function (extension_object) {
                    // Create a value consisting an array of extension objects
                    let node_id = (extension_object["TypeId"][0])["Identifier"][0];
                    let body = extension_object["Body"][0];

                    // InputArguments and OutputArguments will have one of these
                    if (_.has(body, "Argument")) {
                        // console.log("node_id=" + node_id);
                        // console.log("body=" + JSON.stringify(body));

                        // Example Argument payload
                        /*
                            <TypeId>
                                <Identifier>i=297</Identifier>
                            </TypeId>
                            <Body>
                                <Argument>
                                    <Name>FileHandle</Name>
                                    <DataType>
                                        <Identifier>i=7</Identifier>
                                    </DataType>
                                    <ValueRank>-1</ValueRank>
                                    <ArrayDimensions />
                                    <Description p5:nil="true" xmlns:p5="http://www.w3.org/2001/XMLSchema-instance" />
                                </Argument>
                            </Body>
                        */

                        let argument = body["Argument"][0];
                        let name = argument["Name"][0];
                        let data_type = (argument["DataType"][0])["Identifier"][0];
                        let value_rank = argument["ValueRank"][0];
                        let array_dimensions = "None";
                        if (value_rank > 1) {
                            console.log("ERROR: Unsupported array dimensions arg");
                        } else if (value_rank == 1) {
                            console.log("ArrayDimensions is not read - setting dimensions to 0 which means variable length");
                            array_dimensions = "Some(vec![0])"
                        }
                        // var description = argument["Description"][0];
                        var_arguments.push({
                            node_id: node_id,
                            name: name,
                            data_type: data_type,
                            value_rank: value_rank,
                            array_dimensions: array_dimensions,
                        });
                    }
                });


                if (var_arguments.length > 0) {
                    contents += `${indent}let data_value = DataValue::new(vec![\n`;
                    _.each(var_arguments, function (a) {
                        contents += `${indent}    Variant::from(ExtensionObject::from_encodable(\n`;
                        contents += `${indent}        ${node_id_ctor(a.node_id)}, &Argument {\n`;
                        contents += `${indent}            name: UAString::from("${a.name}"),\n`;
                        contents += `${indent}            data_type: ${node_id_ctor(a.data_type)},\n`;
                        contents += `${indent}            value_rank: ${a.value_rank},\n`;
                        contents += `${indent}            array_dimensions: ${a.array_dimensions},\n`;
                        contents += `${indent}            description: LocalizedText::new("", ""),\n`;
                        contents += `${indent}        })),\n`
                    });
                    contents += `${indent}]);\n`;
                    data_value_is_set = true;
                }

                // Turn the array of variants into a variant itself and set as the datavalue
            }
        }
        if (!data_value_is_set) {
            contents += `${indent}let data_value = DataValue::null();\n`
        }
        node_ctor = `Variable::new_data_value(&node_id, browse_name, display_name, description, ${data_type}, data_value)`;
    } else if (node_type === "VariableType") {
        let is_abstract = _.has(node["$"], "IsAbstract") && node["$"]["IsAbstract"] === "true";
        let value_rank = _.has(node["$"], "ValueRank") ? node["$"]["ValueRank"] : -1;
        node_ctor = `VariableType::new(&node_id, browse_name, display_name, description, ${is_abstract}, ${value_rank})`;
    } else if (node_type === "Method") {
        let is_abstract = _.has(node["$"], "IsAbstract") && node["$"]["IsAbstract"] === "true";
        let executable = false; // TODO
        let user_executable = false; // TODO
        node_ctor = `Method::new(&node_id, browse_name, display_name, description, ${is_abstract}, ${executable}, ${user_executable})`;
    }

    let browse_name = _.has(node["$"], "BrowseName") ? node["$"]["BrowseName"] : "";
    contents += `${indent}let browse_name = "${browse_name}";\n`;
    let display_name = _.has(node, "DisplayName") ? node["DisplayName"][0] : "";
    contents += `${indent}let display_name = "${display_name}";\n`;
    let description = _.has(node, "Description") ? node["Description"][0] : "";
    contents += `${indent}let description = "${description}";\n`;

    let node_id = node["$"]["NodeId"];
    contents += `${indent}let node_id = ${node_id_ctor(node_id)};\n`;

    if (trace) {
        contents += `${indent}trace!("Inserting node id ${node_id}of type ${node_type}");\n`;
    }

    contents += `${indent}let node = ${node_ctor};\n`;
    contents += `${indent}address_space.insert(node, `;

    let node_references = [];
    // Organizes reference
    if (_.has(node["$"], "ParentNodeId")) {
        let parent_node_id = node_id_ctor(node["$"]["ParentNodeId"]);
        node_references.push({
            node_other: parent_node_id,
            reference_type: "ReferenceTypeId::Organizes",
            reference_direction: "ReferenceDirection::Inverse",
        })
    }

    // Process other references
    if (_.has(node, "References")) {
        contents += insert_references(indent, node["References"][0], node_references)
    }

    if (node_references.length > 0) {
        contents += "Some(&[\n";
        _.each(node_references, function (r) {
            contents += `${indent}    (&${r.node_other}, ${r.reference_type}, ${r.reference_direction}),\n`;
        });
        contents += `${indent}]));\n`;
    } else {
        contents += "None);\n";
    }

    // Process definitions
    if (_.has(node, "Definition")) {
        // TODO process Fields
    }

    // Process InverseName
    indent = indent.substr(0, indent.length - 4);
    contents += `}\n\n`;

    return contents;
}

function insert_references(indent, reference_element, node_references) {
    var contents = "";
    if (_.has(reference_element, "Reference")) {
        _.each(reference_element["Reference"], function (reference) {
            // Test if the reference is forward or reverse
            var is_forward = !_.has(reference["$"], "IsForward") || reference["$"]["IsForward"] === "true";

            var node_other = node_id_ctor(reference["_"]);
            var reference_type = reference["$"]["ReferenceType"];
            var reference_direction = is_forward ? "ReferenceDirection::Forward" : "ReferenceDirection::Inverse";

            if (reference_type.startsWith("i=")) {
                // TODO
            } else {
                node_references.push({
                    node_other: node_other,
                    reference_type: `ReferenceTypeId::${reference_type}`,
                    reference_direction: reference_direction
                })
            }
        });

    }
    return contents;
}