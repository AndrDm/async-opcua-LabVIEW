var _ = require("lodash");
var fs = require("fs");
var xml2js = require("xml2js");

var settings = require("./settings");


function generate_supported_message(message_types) {
    var file_name = "supported_message.rs";
    var file_path = `${settings.rs_supported_message_dir}/${file_name}`;

    var contents = `// This file was autogenerated by tools/schema/gen_supported_message.js
// DO NOT EDIT THIS FILE

use std::io::{Read, Write};

use encoding::*;
use node_id::NodeId;
use service_types::*;
use node_ids::ObjectId;

macro_rules! impl_into_supported_message {
    [ $( $i:ident, ) * ] => (impl_into_supported_message![ $( $i ),* ];);
    [ $( $i:ident ), * ] => {
        $(
         impl Into<SupportedMessage> for $i {
            fn into(self) -> SupportedMessage { SupportedMessage::$i(self) }
         }
        )*
    };
}

/// This macro helps avoid tedious repetition as new messages are added
/// The first form just handles the trailing comma after the last entry to save some pointless
/// editing when new messages are added to the list.
macro_rules! supported_messages_enum {
    [ $( $x:ident, ) * ] => (supported_messages_enum![ $( $x ),* ];);
    [ $( $x:ident ), * ] => {
        #[derive(Debug, PartialEq, Clone)]
        pub enum SupportedMessage {
            /// An invalid request / response of some form
            Invalid(ObjectId),
            /// Other messages
            $( $x($x), )*
        }

        impl BinaryEncoder <SupportedMessage> for SupportedMessage {
            fn byte_len(&self) -> usize {
                match *self {
                    SupportedMessage::Invalid(object_id) => {
                        panic!("Unsupported message {:?}", object_id);
                    },
                    $( SupportedMessage::$x(ref value) => value.byte_len(), )*
                }
            }

            fn encode<S: Write>(&self, stream: &mut S) -> EncodingResult<usize> {
                match *self {
                    SupportedMessage::Invalid(object_id) => {
                        panic!("Unsupported message {:?}", object_id);
                    },
                    $( SupportedMessage::$x(ref value) => value.encode(stream), )*
                }
            }

            fn decode<S: Read>(_: &mut S) -> EncodingResult<Self> {
                // THIS WILL NOT DO ANYTHING
                panic!("Cannot decode a stream to a supported message type");
            }
        }

        impl SupportedMessage {
            pub fn node_id(&self) -> NodeId {
                match *self {
                    SupportedMessage::Invalid(object_id) => {
                        panic!("Unsupported message {:?}", object_id);
                    },
                    $( SupportedMessage::$x(ref value) => value.object_id().into(), )*
                }
            }
        }
    }
}

impl SupportedMessage {
    pub fn decode_by_object_id<S: Read>(stream: &mut S, object_id: ObjectId) -> EncodingResult<Self> {
        trace!("decoding object_id {:?}", object_id);
        let decoded_message = match object_id {
`;

    _.each(message_types, function (message_type) {
        contents += `            ObjectId::${message_type}_Encoding_DefaultBinary => {
                SupportedMessage::${message_type}(${message_type}::decode(stream)?)
            }
`;
    });

    contents += `
            _ => {
                debug!("decoding unsupported for object id {:?}", object_id);
                SupportedMessage::Invalid(object_id)
            }
        };
        Ok(decoded_message)
    }
}

// These are all the messages handled into and out of streams by the OPCUA server / client code
supported_messages_enum![
`;

    _.each(message_types, function (message_type) {
        contents += `    ${message_type},
`;
    });

    contents += `];

impl_into_supported_message![
`;

    _.each(message_types, function (message_type) {
        contents += `    ${message_type},
`;
    });
    contents += `];
`;


    settings.write_to_file(file_path, contents);
}

// These types are messages which means they implement Into<SupportedMessage> and are processed by supported message
generate_supported_message([
    // A service fault, returned when the service failed
    "ServiceFault",
    // Secure channel service
    "OpenSecureChannelRequest", "OpenSecureChannelResponse",
    "CloseSecureChannelRequest", "CloseSecureChannelResponse",
    // Discovery service
    "GetEndpointsRequest", "GetEndpointsResponse",
    "FindServersRequest", "FindServersResponse",
    "RegisterServerRequest", "RegisterServerResponse",
    // Session service
    "CreateSessionRequest", "CreateSessionResponse",
    "CloseSessionRequest", "CloseSessionResponse",
    "ActivateSessionRequest", "ActivateSessionResponse",
    // MonitoredItem service
    "CreateMonitoredItemsRequest", "CreateMonitoredItemsResponse",
    "ModifyMonitoredItemsRequest", "ModifyMonitoredItemsResponse",
    "DeleteMonitoredItemsRequest", "DeleteMonitoredItemsResponse",
    // Subscription service
    "CreateSubscriptionRequest", "CreateSubscriptionResponse",
    "ModifySubscriptionRequest", "ModifySubscriptionResponse",
    "DeleteSubscriptionsRequest", "DeleteSubscriptionsResponse",
    "SetPublishingModeRequest", "SetPublishingModeResponse",
    // View service
    "BrowseRequest", "BrowseResponse",
    "BrowseNextRequest", "BrowseNextResponse",
    "PublishRequest", "PublishResponse",
    "RepublishRequest", "RepublishResponse",
    "TranslateBrowsePathsToNodeIdsRequest", "TranslateBrowsePathsToNodeIdsResponse",
    // Attribute service
    "ReadRequest", "ReadResponse",
    "WriteRequest", "WriteResponse",
    // Method service
    "CallRequest", "CallResponse",
])