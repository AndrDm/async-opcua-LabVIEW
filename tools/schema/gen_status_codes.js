var _ = require("lodash");
var csv = require("csv-parser");
var fs = require("fs");

var settings = require("./settings");

var status_code_csv = `${settings.schema_dir}/Opc.Ua.StatusCodes.csv`;

var rs_out = fs.createWriteStream(`${settings.rs_types_dir}/status_codes.rs`);

var status_codes = [
    {
        var_name: "GOOD",
        str_code: "Good",
        hex_code: 0,
        description: "Good"
    }
];

fs.createReadStream(status_code_csv)
    .pipe(csv(['str_code', 'hex_code', 'description']))
    .on('data', function (data) {
        data.var_name = _.toUpper(_.snakeCase(data.str_code));
        status_codes.push(data);
    })
    .on('end', function () {
        // Sort status
        status_codes = _.sortBy(status_codes, ['hex_code']);

        rs_out.write(
            `// This file was autogenerated from Opc.Ua.StatusCodes.csv
// DO NOT EDIT THIS FILE

use std;
use std::io::{Read, Write};

use super::super::*;

#[allow(non_camel_case_types)]
#[derive(PartialEq, Debug, Copy, Clone)]
pub enum StatusCode {
`);
        _.each(status_codes, function (data) {
            rs_out.write(`    ${data.var_name} = ${data.hex_code},\n`);
        });
        rs_out.write(
            `}

impl BinaryEncoder<StatusCode> for StatusCode {
    fn byte_len(&self) -> usize {
        4
    }

    fn encode<S: Write>(&self, stream: &mut S) -> EncodingResult<usize> {
        write_u32(stream, *self as u32)
    }

    fn decode<S: Read>(stream: &mut S) -> EncodingResult<Self> {
        let code = read_u32(stream)?;
        let status_code = StatusCode::from_u32(code);
        if status_code.is_ok() { Ok(status_code.unwrap()) } else { Ok(BAD_UNEXPECTED_ERROR) }
    }
}

impl StatusCode {
    /// Tests if the status code is bad
    pub fn is_bad(&self) -> bool {
        ((*self as u32) & 0x80000000) != 0
    }

    /// Tests if the status code is uncertain
    pub fn is_uncertain(&self) -> bool {
        ((*self as u32) & 0x40000000) != 0
    }

    /// Tests if the status code is good (i.e. not bad or uncertain)
    pub fn is_good(&self) -> bool {
        !self.is_bad() && !self.is_uncertain()
    }
`);

        rs_out.write(`
    /// Returns the descriptive name for the status code, e.g. to put a meaningful code in a log file
    pub fn name(&self) -> &'static str {
        match *self {
`);
        _.each(status_codes, function (data) {
            rs_out.write(`            ${data.var_name} => "${data.str_code}",\n`);
        });
        rs_out.write(`        }
    }
`);

        rs_out.write(`
    /// Returns the descriptive text for the status code
    pub fn description(&self) -> &'static str {
        match *self {
`);
        _.each(status_codes, function (data) {
            rs_out.write(`            ${data.var_name} => "${data.description}",\n`);
        });
        rs_out.write(`        }
    }
`);

        rs_out.write(`
    /// Takes an OPC UA status code as a UInt32 and returns the matching StatusCode, assuming there is one
    pub fn from_u32(code: u32) -> std::result::Result<StatusCode, ()> {
        match code {
`);
        _.each(status_codes, function (data) {
            rs_out.write(`            ${data.hex_code} => Ok(${data.var_name}),\n`);
        });
        rs_out.write(
            `            _ => Err(())
        }
    }

    /// Takes an OPC UA status code as a string and returns the matching StatusCode - assuming there is one
    pub fn from_str(name: &str) -> std::result::Result<StatusCode, ()> {
        match name {
`);
        _.each(status_codes, function (data) {
            rs_out.write(`            "${data.str_code}" => Ok(${data.var_name}),\n`);
        });
        rs_out.write(`            _ => Err(())
        }
    }
}

`);

        rs_out.write(``);

    });
